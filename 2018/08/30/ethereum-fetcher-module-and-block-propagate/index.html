<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lessisbetter.site","root":"/","images":"/images","scheme":"Pisces","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="前言这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。 当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。">
<meta property="og:type" content="article">
<meta property="og:title" content="以太坊源码分析：fetcher模块和区块传播">
<meta property="og:url" content="http://lessisbetter.site/2018/08/30/ethereum-fetcher-module-and-block-propagate/index.html">
<meta property="og:site_name" content="Go语言充电站">
<meta property="og:description" content="前言这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。 当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.lessisbetter.site/image-20180821115214521.png-own">
<meta property="og:image" content="http://img.lessisbetter.site/image-20180821114210114.png-own">
<meta property="og:image" content="http://img.lessisbetter.site/image-20180821114756055.png-own">
<meta property="og:image" content="http://img.lessisbetter.site/image-20180821175330370.png-own">
<meta property="og:image" content="http://img.lessisbetter.site/image-20180821115537184.png-own">
<meta property="og:image" content="http://img.lessisbetter.site/image-20180821143403650.png-own">
<meta property="og:image" content="http://img.lessisbetter.site/image-20180822103401508.png-own">
<meta property="og:image" content="http://img.lessisbetter.site/image-20180822103701006.png-own">
<meta property="article:published_time" content="2018-08-30T08:49:47.000Z">
<meta property="article:modified_time" content="2020-12-13T08:11:59.774Z">
<meta property="article:author" content="大彬">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="以太坊">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.lessisbetter.site/image-20180821115214521.png-own">


<link rel="canonical" href="http://lessisbetter.site/2018/08/30/ethereum-fetcher-module-and-block-propagate/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>以太坊源码分析：fetcher模块和区块传播 | Go语言充电站</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Go语言充电站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">大彬 less is better</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li>
        <li class="menu-item menu-item-关于"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-专题"><a href="/subject/" rel="section"><i class="fa fa-calendar fa-fw"></i>专题</a></li>
        <li class="menu-item menu-item-大牛博客"><a href="/blogs/" rel="section"><i class="fa fa-calendar fa-fw"></i>大牛博客</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E8%BF%87%E7%A8%8B%E5%92%8C%E4%BC%A0%E6%92%AD%E7%AD%96%E7%95%A5"><span class="nav-number">2.</span> <span class="nav-text">总体过程和传播策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Fetcher%E6%A8%A1%E5%9D%97%E6%98%AF%E5%B9%B2%E5%95%A5%E7%9A%84"><span class="nav-number">3.</span> <span class="nav-text">Fetcher模块是干啥的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="nav-number">4.</span> <span class="nav-text">源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%A7%E5%9D%97%E8%8A%82%E7%82%B9%E7%9A%84%E4%BC%A0%E6%92%AD%E6%96%B0%E5%8C%BA%E5%9D%97"><span class="nav-number">4.1.</span> <span class="nav-text">产块节点的传播新区块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Peer%E8%8A%82%E7%82%B9%E5%A4%84%E7%90%86%E6%96%B0%E5%8C%BA%E5%9D%97"><span class="nav-number">4.2.</span> <span class="nav-text">Peer节点处理新区块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NewBlockMsg%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">4.2.1.</span> <span class="nav-text">NewBlockMsg的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fetcher%E9%98%9F%E5%88%97%E5%A4%84%E7%90%86"><span class="nav-number">4.2.2.</span> <span class="nav-text">fetcher队列处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NewBlockHashesMsg%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">4.2.3.</span> <span class="nav-text">NewBlockHashesMsg的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fetcher%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E5%8C%BA%E5%9D%97"><span class="nav-number">4.2.4.</span> <span class="nav-text">fetcher获取完整区块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fetcher%E7%9A%84%E5%A4%A7%E5%A4%B4"><span class="nav-number">4.3.</span> <span class="nav-text">Fetcher的大头</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E8%A7%82"><span class="nav-number">4.3.1.</span> <span class="nav-text">宏观</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E8%A7%82"><span class="nav-number">4.3.2.</span> <span class="nav-text">微观</span></a></li></ol></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="大彬"
      src="https://github.com/Shitaibin/shitaibin.github.io/blob/hexo_resource/images/gzh-qrcode-logo-small.png">
  <p class="site-author-name" itemprop="name">大彬</p>
  <div class="site-description" itemprop="description">云原生、Go语言、区块链</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">137</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://xargin.com/" title="Xargin曹大博客 → https:&#x2F;&#x2F;xargin.com&#x2F;" rel="noopener" target="_blank">Xargin曹大博客</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://qcrao.github.io/" title="码农桃花源博客 → https:&#x2F;&#x2F;qcrao.github.io&#x2F;" rel="noopener" target="_blank">码农桃花源博客</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://book.eddycjy.com/golang/" title="煎鱼博客 → https:&#x2F;&#x2F;book.eddycjy.com&#x2F;golang&#x2F;" rel="noopener" target="_blank">煎鱼博客</a>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lessisbetter.site/2018/08/30/ethereum-fetcher-module-and-block-propagate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://github.com/Shitaibin/shitaibin.github.io/blob/hexo_resource/images/gzh-qrcode-logo-small.png">
      <meta itemprop="name" content="大彬">
      <meta itemprop="description" content="云原生、Go语言、区块链">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Go语言充电站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          以太坊源码分析：fetcher模块和区块传播
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-08-30 16:49:47" itemprop="dateCreated datePublished" datetime="2018-08-30T16:49:47+08:00">2018-08-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-13 16:11:59" itemprop="dateModified" datetime="2020-12-13T16:11:59+08:00">2020-12-13</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章从区块传播策略入手，介绍新区块是如何传播到远端节点，以及新区块加入到远端节点本地链的过程，同时会介绍fetcher模块，fetcher的功能是处理Peer通知的区块信息。在介绍过程中，还会涉及到p2p，eth等模块，不会专门介绍，而是专注区块的传播和加入区块链的过程。</p>
<p>当前代码是以太坊Release 1.8，如果版本不同，代码上可能存在差异。</p>
<a id="more"></a>

<h1 id="总体过程和传播策略"><a href="#总体过程和传播策略" class="headerlink" title="总体过程和传播策略"></a>总体过程和传播策略</h1><p>本节从宏观角度介绍，节点产生区块后，为了传播给远端节点做了啥，远端节点收到区块后又做了什么，每个节点都连接了很多Peer，它传播的策略是什么样的？</p>
<p>总体流程和策略可以总结为，传播给远端Peer节点，Peer验证区块无误后，加入到本地区块链，继续传播新区块信息。具体过程如下。</p>
<p>先看总体过程。产生区块后，<code>miner</code>模块会发布一个事件<code>NewMinedBlockEvent</code>，订阅事件的协程收到事件后，就会把新区块的消息，广播给它所有的peer，peer收到消息后，会交给自己的fetcher模块处理，fetcher进行基本的验证后，区块没问题，发现这个区块就是本地链需要的下一个区块，则交给<code>blockChain</code>进一步进行完整的验证，这个过程会执行区块所有的交易，无误后把区块加入到本地链，写入数据库，这个过程就是下面的流程图，图1。</p>
<p><img src="http://img.lessisbetter.site/image-20180821115214521.png-own" alt="图1：新区块传播总体流程图"></p>
<p>总体流程图，能看到有个分叉，是因为节点传播新区块是有策略的。它的传播策略为：</p>
<ol>
<li>假如节点连接了<code>N</code>个Peer，它只向Peer列表的<code>sqrt(N)</code>个Peer广播<strong>完整的区块</strong>消息。</li>
<li>向所有的Peer广播<strong>只包含区块Hash</strong>的消息。</li>
</ol>
<p>策略图的效果如图2，红色节点将区块传播给黄色节点：<img src="http://img.lessisbetter.site/image-20180821114210114.png-own" alt="图2：产生区块后传播给相邻节点"></p>
<p>收到区块Hash的节点，需要从发送给它消息的Peer那里获取对应的完整区块，获取区块后就会按照图1的流程，加入到fetcher队列，最终插入本地区块链后，<strong>将区块的Hash值广播给和它相连，但还不知道这个区块的Peer</strong>。非产生区块节点的策略图，如图3，黄色节点将区块Hash传播给青色节点：<img src="http://img.lessisbetter.site/image-20180821114756055.png-own" alt="图3：非产块节点传播新区块"></p>
<p>至此，可以看出<strong>以太坊采用以石击水的方式，像水纹一样，层层扩散新产生的区块</strong>。</p>
<h1 id="Fetcher模块是干啥的"><a href="#Fetcher模块是干啥的" class="headerlink" title="Fetcher模块是干啥的"></a>Fetcher模块是干啥的</h1><p>fetcher模块的功能，就是收集其他Peer通知它的区块信息：1）完整的区块2）区块Hash消息。根据通知的消息，获取完整的区块，然后传递给<code>eth</code>模块把区块插入区块链。</p>
<p>如果是完整区块，就可以传递给eth插入区块，如果只有区块Hash，则需要从其他的Peer获取此完整的区块，然后再传递给eth插入区块。</p>
<p><img src="http://img.lessisbetter.site/image-20180821175330370.png-own" alt="fetcher功能抽象"></p>
<h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>本节介绍区块传播和处理的细节东西，方式仍然是先用图解释流程，再是代码流程。</p>
<h2 id="产块节点的传播新区块"><a href="#产块节点的传播新区块" class="headerlink" title="产块节点的传播新区块"></a>产块节点的传播新区块</h2><p>节点产生区块后，广播的流程可以表示为图4：</p>
<ol>
<li>发布事件</li>
<li>事件处理函数选择要广播完整的Peer，然后将区块加入到它们的队列</li>
<li>事件处理函数把区块Hash添加到所有Peer的另外一个通知队列</li>
<li>每个Peer的广播处理函数，会遍历它的待广播区块队列和通知队列，把数据封装成消息，调用P2P接口发送出去</li>
</ol>
<p><img src="http://img.lessisbetter.site/image-20180821115537184.png-own" alt="图4：产块节点的传播图"></p>
<p>再看下代码上的细节。</p>
<ol>
<li><code>worker.wait()</code>函数发布事件<code>NewMinedBlockEvent</code>。</li>
<li><code>ProtocolManager.minedBroadcastLoop()</code>是事件处理函数。它调用了2次<code>pm.BroadcastBlock()</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mined broadcast loop</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">minedBroadcastLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// automatically stops if unsubscribe</span></span><br><span class="line">	<span class="keyword">for</span> obj := <span class="keyword">range</span> pm.minedBlockSub.Chan() &#123;</span><br><span class="line">		<span class="keyword">switch</span> ev := obj.Data.(<span class="keyword">type</span>) &#123;</span><br><span class="line">		<span class="keyword">case</span> core.NewMinedBlockEvent:</span><br><span class="line">			pm.BroadcastBlock(ev.Block, <span class="literal">true</span>)  <span class="comment">// First propagate block to peers</span></span><br><span class="line">			pm.BroadcastBlock(ev.Block, <span class="literal">false</span>) <span class="comment">// Only then announce to the rest</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>pm.BroadcastBlock()</code>的入参<code>propagate</code>为真时，向部分Peer广播完整的区块，调用<code>peer.AsyncSendNewBlock()</code>，否则向所有Peer广播区块头，调用<code>peer.AsyncSendNewBlockHash()</code>，这2个函数就是把数据放入队列，此处不再放代码。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BroadcastBlock will either propagate a block to a subset of it&#x27;s peers, or</span></span><br><span class="line"><span class="comment">// will only announce it&#x27;s availability (depending what&#x27;s requested).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pm *ProtocolManager)</span> <span class="title">BroadcastBlock</span><span class="params">(block *types.Block, propagate <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	hash := block.Hash()</span><br><span class="line">	peers := pm.peers.PeersWithoutBlock(hash)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If propagation is requested, send to a subset of the peer</span></span><br><span class="line">	<span class="comment">// 这种情况，要把区块广播给部分peer</span></span><br><span class="line">	<span class="keyword">if</span> propagate &#123;</span><br><span class="line">		<span class="comment">// Calculate the TD of the block (it&#x27;s not imported yet, so block.Td is not valid)</span></span><br><span class="line">		<span class="comment">// 计算新的总难度</span></span><br><span class="line">		<span class="keyword">var</span> td *big.Int</span><br><span class="line">		<span class="keyword">if</span> parent := pm.blockchain.GetBlock(block.ParentHash(), block.NumberU64()<span class="number">-1</span>); parent != <span class="literal">nil</span> &#123;</span><br><span class="line">			td = <span class="built_in">new</span>(big.Int).Add(block.Difficulty(), pm.blockchain.GetTd(block.ParentHash(), block.NumberU64()<span class="number">-1</span>))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.Error(<span class="string">&quot;Propagating dangling block&quot;</span>, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send the block to a subset of our peers</span></span><br><span class="line">		<span class="comment">// 广播区块给部分peer</span></span><br><span class="line">		transfer := peers[:<span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(<span class="built_in">len</span>(peers))))]</span><br><span class="line">		<span class="keyword">for</span> _, peer := <span class="keyword">range</span> transfer &#123;</span><br><span class="line">			peer.AsyncSendNewBlock(block, td)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Trace(<span class="string">&quot;Propagated block&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;recipients&quot;</span>, <span class="built_in">len</span>(transfer), <span class="string">&quot;duration&quot;</span>, common.PrettyDuration(time.Since(block.ReceivedAt)))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Otherwise if the block is indeed in out own chain, announce it</span></span><br><span class="line">	<span class="comment">// 把区块hash值广播给所有peer</span></span><br><span class="line">	<span class="keyword">if</span> pm.blockchain.HasBlock(hash, block.NumberU64()) &#123;</span><br><span class="line">		<span class="keyword">for</span> _, peer := <span class="keyword">range</span> peers &#123;</span><br><span class="line">			peer.AsyncSendNewBlockHash(block)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Trace(<span class="string">&quot;Announced block&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;recipients&quot;</span>, <span class="built_in">len</span>(peers), <span class="string">&quot;duration&quot;</span>, common.PrettyDuration(time.Since(block.ReceivedAt)))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>peer.broadcase()</code>是每个Peer连接的广播函数，它只广播3种消息：交易、完整的区块、区块的Hash，这样表明了节点只会主动广播这3中类型的数据，剩余的数据同步，都是通过<strong>请求-响应</strong>的方式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// broadcast is a write loop that multiplexes block propagations, announcements</span></span><br><span class="line"><span class="comment">// and transaction broadcasts into the remote peer. The goal is to have an async</span></span><br><span class="line"><span class="comment">// writer that does not lock up node internals.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span> <span class="title">broadcast</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 广播交易</span></span><br><span class="line">		<span class="keyword">case</span> txs := &lt;-p.queuedTxs:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendTransactions(txs); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">&quot;Broadcast transactions&quot;</span>, <span class="string">&quot;count&quot;</span>, <span class="built_in">len</span>(txs))</span><br><span class="line">		<span class="comment">// 广播完整的新区块</span></span><br><span class="line">		<span class="keyword">case</span> prop := &lt;-p.queuedProps:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendNewBlock(prop.block, prop.td); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">&quot;Propagated block&quot;</span>, <span class="string">&quot;number&quot;</span>, prop.block.Number(), <span class="string">&quot;hash&quot;</span>, prop.block.Hash(), <span class="string">&quot;td&quot;</span>, prop.td)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 广播区块Hash</span></span><br><span class="line">		<span class="keyword">case</span> block := &lt;-p.queuedAnns:</span><br><span class="line">			<span class="keyword">if</span> err := p.SendNewBlockHashes([]common.Hash&#123;block.Hash()&#125;, []<span class="keyword">uint64</span>&#123;block.NumberU64()&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Trace(<span class="string">&quot;Announced block&quot;</span>, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, block.Hash())</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-p.term:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="Peer节点处理新区块"><a href="#Peer节点处理新区块" class="headerlink" title="Peer节点处理新区块"></a>Peer节点处理新区块</h2><p>本节介绍远端节点收到2种区块同步消息的处理，其中<code>NewBlockMsg</code>的处理流程比较清晰，也简洁。<code>NewBlockHashesMsg</code>消息的处理就绕了2绕，从总体流程图1上能看出来，它需要先从给他发送消息Peer那里获取到完整的区块，剩下的流程和<code>NewBlockMsg</code>又一致了。</p>
<p>这部分涉及的模块多，画出来有种眼花缭乱的感觉，但只要抓住上面的主线，代码看起来还是很清晰的。通过图5先看下整体流程。</p>
<p>消息处理的起点是<code>ProtocolManager.handleMsg</code>，<code>NewBlockMsg</code>的处理流程是蓝色标记的区域，红色区域是单独的协程，是fetcher处理队列中区块的流程，如果从队列中取出的区块是当前链需要的，校验后，调用<code>blockchian.InsertChain()</code>把区块插入到区块链，最后写入数据库，这是黄色部分。最后，绿色部分是<code>NewBlockHashesMsg</code>的处理流程，代码流程上是比较复杂的，为了能通过图描述整体流程，我把它简化掉了。</p>
<p><img src="http://img.lessisbetter.site/image-20180821143403650.png-own" alt="图5：远端节点处理新区块"></p>
<p>仔细看看这幅图，掌握整体的流程后，接下来看每个步骤的细节。</p>
<h3 id="NewBlockMsg的处理"><a href="#NewBlockMsg的处理" class="headerlink" title="NewBlockMsg的处理"></a>NewBlockMsg的处理</h3><p>本节介绍节点收到完整区块的处理，流程如下：</p>
<ol>
<li>首先进行RLP编解码，然后标记发送消息的Peer已经知道这个区块，这样本节点最后广播这个区块的Hash时，不会再发送给该Peer。</li>
<li>将区块存入到fetcher的队列，<code>调用fetcher.Enqueue</code>。</li>
<li>更新Peer的Head位置，然后判断本地链是否落后于Peer的链，如果是，则通过Peer更新本地链。</li>
</ol>
<p>只看<code>handle.Msg()</code>的<code>NewBlockMsg</code>相关的部分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> msg.Code == NewBlockMsg:</span><br><span class="line">	<span class="comment">// Retrieve and decode the propagated block</span></span><br><span class="line">	<span class="comment">// 收到新区块，解码，赋值接收数据</span></span><br><span class="line">	<span class="keyword">var</span> request newBlockData</span><br><span class="line">	<span class="keyword">if</span> err := msg.Decode(&amp;request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errResp(ErrDecode, <span class="string">&quot;%v: %v&quot;</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">	request.Block.ReceivedAt = msg.ReceivedAt</span><br><span class="line">	request.Block.ReceivedFrom = p</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark the peer as owning the block and schedule it for import</span></span><br><span class="line">	<span class="comment">// 标记peer知道这个区块</span></span><br><span class="line">	p.MarkBlock(request.Block.Hash())</span><br><span class="line">	<span class="comment">// 为啥要如队列？已经得到完整的区块了</span></span><br><span class="line">	<span class="comment">// 答：存入fetcher的优先级队列，fetcher会从队列中选取当前高度需要的块</span></span><br><span class="line">	pm.fetcher.Enqueue(p.id, request.Block)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assuming the block is importable by the peer, but possibly not yet done so,</span></span><br><span class="line">	<span class="comment">// calculate the head hash and TD that the peer truly must have.</span></span><br><span class="line">	<span class="comment">// 截止到parent区块的头和难度</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		trueHead = request.Block.ParentHash()</span><br><span class="line">		trueTD   = <span class="built_in">new</span>(big.Int).Sub(request.TD, request.Block.Difficulty())</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// Update the peers total difficulty if better than the previous</span></span><br><span class="line">	<span class="comment">// 如果收到的块的难度大于peer之前的，以及自己本地的，就去和这个peer同步</span></span><br><span class="line">	<span class="comment">// 问题：就只用了一下块里的hash值，为啥不直接使用这个块呢，如果这个块不能用，干嘛不少发送些数据，减少网络负载呢。</span></span><br><span class="line">	<span class="comment">// 答案：实际上，这个块加入到了优先级队列中，当fetcher的loop检查到当前下一个区块的高度，正是队列中有的，则不再向peer请求</span></span><br><span class="line">	<span class="comment">// 该区块，而是直接使用该区块，检查无误后交给block chain执行insertChain</span></span><br><span class="line">	<span class="keyword">if</span> _, td := p.Head(); trueTD.Cmp(td) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		p.SetHead(trueHead, trueTD)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Schedule a sync if above ours. Note, this will not fire a sync for a gap of</span></span><br><span class="line">		<span class="comment">// a singe block (as the true TD is below the propagated block), however this</span></span><br><span class="line">		<span class="comment">// scenario should easily be covered by the fetcher.</span></span><br><span class="line">		currentBlock := pm.blockchain.CurrentBlock()</span><br><span class="line">		<span class="keyword">if</span> trueTD.Cmp(pm.blockchain.GetTd(currentBlock.Hash(), currentBlock.NumberU64())) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> pm.synchronise(p)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//------------------------ 以上 handleMsg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Enqueue tries to fill gaps the the fetcher&#x27;s future import queue.</span></span><br><span class="line"><span class="comment">// 发给inject通道，当前协程在handleMsg，通过通道发送给fetcher的协程处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">Enqueue</span><span class="params">(peer <span class="keyword">string</span>, block *types.Block)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	op := &amp;inject&#123;</span><br><span class="line">		origin: peer,</span><br><span class="line">		block:  block,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.inject &lt;- op:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> errTerminated</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------ 以下 fetcher.loop处理inject部分</span></span><br><span class="line"><span class="keyword">case</span> op := &lt;-f.inject:</span><br><span class="line">	<span class="comment">// A direct block insertion was requested, try and fill any pending gaps</span></span><br><span class="line">	<span class="comment">// 区块加入队列，首先也填入未决的间距</span></span><br><span class="line">	propBroadcastInMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	f.enqueue(op.origin, op.block)</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------  如队列函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// enqueue schedules a new future import operation, if the block to be imported</span></span><br><span class="line"><span class="comment">// has not yet been seen.</span></span><br><span class="line"><span class="comment">// 把导入的新区块加入到队列，主要操作queue, queues, queued这3个变量，quque用来保存要插入的区块，</span></span><br><span class="line"><span class="comment">// 按高度排序，queues记录了在队列中某个peer传来的区块的数量，用来做对抗DoS攻击，queued用来</span></span><br><span class="line"><span class="comment">// 判断某个区块是否已经在队列，防止2次插入，浪费时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">enqueue</span><span class="params">(peer <span class="keyword">string</span>, block *types.Block)</span></span> &#123;</span><br><span class="line">	hash := block.Hash()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ensure the peer isn&#x27;t DOSing us</span></span><br><span class="line">	<span class="comment">// 防止peer的DOS攻击</span></span><br><span class="line">	count := f.queues[peer] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; blockLimit &#123;</span><br><span class="line">		log.Debug(<span class="string">&quot;Discarded propagated block, exceeded allowance&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;limit&quot;</span>, blockLimit)</span><br><span class="line">		propBroadcastDOSMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		f.forgetHash(hash)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Discard any past or too distant blocks</span></span><br><span class="line">	<span class="comment">// 高度检查：未来太远的块丢弃</span></span><br><span class="line">	<span class="keyword">if</span> dist := <span class="keyword">int64</span>(block.NumberU64()) - <span class="keyword">int64</span>(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist &#123;</span><br><span class="line">		log.Debug(<span class="string">&quot;Discarded propagated block, too far away&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;distance&quot;</span>, dist)</span><br><span class="line">		propBroadcastDropMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		f.forgetHash(hash)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the block for future importing</span></span><br><span class="line">	<span class="comment">// 块先加入优先级队列，加入链之前，还有很多要做</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := f.queued[hash]; !ok &#123;</span><br><span class="line">		op := &amp;inject&#123;</span><br><span class="line">			origin: peer,</span><br><span class="line">			block:  block,</span><br><span class="line">		&#125;</span><br><span class="line">		f.queues[peer] = count</span><br><span class="line">		f.queued[hash] = op</span><br><span class="line">		f.queue.Push(op, -<span class="keyword">float32</span>(block.NumberU64()))</span><br><span class="line">		<span class="keyword">if</span> f.queueChangeHook != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.queueChangeHook(op.block.Hash(), <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		log.Debug(<span class="string">&quot;Queued propagated block&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;queued&quot;</span>, f.queue.Size())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fetcher队列处理"><a href="#fetcher队列处理" class="headerlink" title="fetcher队列处理"></a>fetcher队列处理</h3><p>本节我们看看，区块加入队列后，fetcher如何处理区块，为何不直接校验区块，插入到本地链？</p>
<p>由于以太坊又Uncle的机制，节点可能收到老一点的一些区块。另外，节点可能由于网络原因，落后了几个区块，所以可能收到“未来”的一些区块，这些区块都不能直接插入到本地链。</p>
<p>区块入的队列是一个优先级队列，高度低的区块会被优先取出来。<code>fetcher.loop</code>是单独协程，不断运转，清理fecther中的事务和事件。首先会清理正在<code>fetching</code>的区块，但已经超时。然后处理优先级队列中的区块，判断高度是否是下一个区块，如果是则调用<code>f.insert()</code>函数，校验后调用<code>BlockChain.InsertChain()</code>，成功插入后，<strong>广播新区块的Hash</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Loop is the main fetcher loop, checking and processing various notification</span></span><br><span class="line"><span class="comment">// events.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">loop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Iterate the block fetching until a quit is requested</span></span><br><span class="line">	fetchTimer := time.NewTimer(<span class="number">0</span>)</span><br><span class="line">	completeTimer := time.NewTimer(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Clean up any expired block fetches</span></span><br><span class="line">		<span class="comment">// 清理过期的区块</span></span><br><span class="line">		<span class="keyword">for</span> hash, announce := <span class="keyword">range</span> f.fetching &#123;</span><br><span class="line">			<span class="keyword">if</span> time.Since(announce.time) &gt; fetchTimeout &#123;</span><br><span class="line">				f.forgetHash(hash)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Import any queued blocks that could potentially fit</span></span><br><span class="line">		<span class="comment">// 导入队列中合适的块</span></span><br><span class="line">		height := f.chainHeight()</span><br><span class="line">		<span class="keyword">for</span> !f.queue.Empty() &#123;</span><br><span class="line">			op := f.queue.PopItem().(*inject)</span><br><span class="line">			hash := op.block.Hash()</span><br><span class="line">			<span class="keyword">if</span> f.queueChangeHook != <span class="literal">nil</span> &#123;</span><br><span class="line">				f.queueChangeHook(hash, <span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// If too high up the chain or phase, continue later</span></span><br><span class="line">			<span class="comment">// 块不是链需要的下一个块，再入优先级队列，停止循环</span></span><br><span class="line">			number := op.block.NumberU64()</span><br><span class="line">			<span class="keyword">if</span> number &gt; height+<span class="number">1</span> &#123;</span><br><span class="line">				f.queue.Push(op, -<span class="keyword">float32</span>(number))</span><br><span class="line">				<span class="keyword">if</span> f.queueChangeHook != <span class="literal">nil</span> &#123;</span><br><span class="line">					f.queueChangeHook(hash, <span class="literal">true</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Otherwise if fresh and still unknown, try and import</span></span><br><span class="line">			<span class="comment">// 高度正好是我们想要的，并且链上也没有这个块</span></span><br><span class="line">			<span class="keyword">if</span> number+maxUncleDist &lt; height || f.getBlock(hash) != <span class="literal">nil</span> &#123;</span><br><span class="line">				f.forgetBlock(hash)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 那么，块插入链</span></span><br><span class="line">			f.insert(op.origin, op.block)</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">insert</span><span class="params">(peer <span class="keyword">string</span>, block *types.Block)</span></span> &#123;</span><br><span class="line">	hash := block.Hash()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Run the import on a new thread</span></span><br><span class="line">	log.Debug(<span class="string">&quot;Importing propagated block&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; f.done &lt;- hash &#125;()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the parent&#x27;s unknown, abort insertion</span></span><br><span class="line">		parent := f.getBlock(block.ParentHash())</span><br><span class="line">		<span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">&quot;Unknown parent of propagated block&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;parent&quot;</span>, block.ParentHash())</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Quickly validate the header and propagate the block if it passes</span></span><br><span class="line">		<span class="comment">// 验证区块头，成功后广播区块</span></span><br><span class="line">		<span class="keyword">switch</span> err := f.verifyHeader(block.Header()); err &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">			<span class="comment">// All ok, quickly propagate to our peers</span></span><br><span class="line">			propBroadcastOutTimer.UpdateSince(block.ReceivedAt)</span><br><span class="line">			<span class="keyword">go</span> f.broadcastBlock(block, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> consensus.ErrFutureBlock:</span><br><span class="line">			<span class="comment">// Weird future block, don&#x27;t fail, but neither propagate</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">// Something went very wrong, drop the peer</span></span><br><span class="line">			log.Debug(<span class="string">&quot;Propagated block verification failed&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			f.dropPeer(peer)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Run the actual import and log any issues</span></span><br><span class="line">		<span class="comment">// 调用回调函数，实际是blockChain.insertChain</span></span><br><span class="line">		<span class="keyword">if</span> _, err := f.insertChain(types.Blocks&#123;block&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">&quot;Propagated block import failed&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;number&quot;</span>, block.Number(), <span class="string">&quot;hash&quot;</span>, hash, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If import succeeded, broadcast the block</span></span><br><span class="line">		propAnnounceOutTimer.UpdateSince(block.ReceivedAt)</span><br><span class="line">		<span class="keyword">go</span> f.broadcastBlock(block, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Invoke the testing hook if needed</span></span><br><span class="line">		<span class="keyword">if</span> f.importedHook != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.importedHook(block)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NewBlockHashesMsg的处理"><a href="#NewBlockHashesMsg的处理" class="headerlink" title="NewBlockHashesMsg的处理"></a>NewBlockHashesMsg的处理</h3><p>本节介绍NewBlockHashesMsg的处理，其实，消息处理是简单的，而复杂一点的是从Peer哪获取完整的区块，下节再看。</p>
<p>流程如下:</p>
<ol>
<li>对消息进行RLP解码，然后标记Peer已经知道此区块。</li>
<li>寻找出本地区块链不存在的区块Hash值，把这些未知的Hash通知给fetcher。</li>
<li><code>fetcher.Notify</code>记录好通知信息，塞入<code>notify</code>通道，以便交给fetcher的协程。</li>
<li><code>fetcher.loop()</code>会对<code>notify</code>中的消息进行处理，确认区块并非DOS攻击，然后检查区块的高度，判断该区块是否已经在<code>fetching</code>或者<code>comleting(代表已经下载区块头，在下载body)</code>，如果都没有，则加入到<code>announced</code>中，触发0s定时器，进行处理。</li>
</ol>
<p>关于<code>announced</code>下节再介绍。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMsg()部分</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == NewBlockHashesMsg:</span><br><span class="line">	<span class="keyword">var</span> announces newBlockHashesData</span><br><span class="line">	<span class="keyword">if</span> err := msg.Decode(&amp;announces); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errResp(ErrDecode, <span class="string">&quot;%v: %v&quot;</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Mark the hashes as present at the remote node</span></span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> announces &#123;</span><br><span class="line">		p.MarkBlock(block.Hash)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule all the unknown hashes for retrieval</span></span><br><span class="line">	<span class="comment">// 把本地链没有的块hash找出来，交给fetcher去下载</span></span><br><span class="line">	unknown := <span class="built_in">make</span>(newBlockHashesData, <span class="number">0</span>, <span class="built_in">len</span>(announces))</span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> announces &#123;</span><br><span class="line">		<span class="keyword">if</span> !pm.blockchain.HasBlock(block.Hash, block.Number) &#123;</span><br><span class="line">			unknown = <span class="built_in">append</span>(unknown, block)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> unknown &#123;</span><br><span class="line">		pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Notify announces the fetcher of the potential availability of a new block in</span></span><br><span class="line"><span class="comment">// the network.</span></span><br><span class="line"><span class="comment">// 通知fetcher（自己）有新块产生，没有块实体，有hash、高度等信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">Notify</span><span class="params">(peer <span class="keyword">string</span>, hash common.Hash, number <span class="keyword">uint64</span>, time time.Time,</span></span></span><br><span class="line"><span class="function"><span class="params">	headerFetcher headerRequesterFn, bodyFetcher bodyRequesterFn)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	block := &amp;announce&#123;</span><br><span class="line">		hash:        hash,</span><br><span class="line">		number:      number,</span><br><span class="line">		time:        time,</span><br><span class="line">		origin:      peer,</span><br><span class="line">		fetchHeader: headerFetcher,</span><br><span class="line">		fetchBodies: bodyFetcher,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.notify &lt;- block:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> errTerminated</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetcher.loop()的notify通道消息处理</span></span><br><span class="line"><span class="keyword">case</span> notification := &lt;-f.notify:</span><br><span class="line">	<span class="comment">// A block was announced, make sure the peer isn&#x27;t DOSing us</span></span><br><span class="line">	propAnnounceInMeter.Mark(<span class="number">1</span>)</span><br><span class="line">	count := f.announces[notification.origin] + <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> count &gt; hashLimit &#123;</span><br><span class="line">		log.Debug(<span class="string">&quot;Peer exceeded outstanding announces&quot;</span>, <span class="string">&quot;peer&quot;</span>, notification.origin, <span class="string">&quot;limit&quot;</span>, hashLimit)</span><br><span class="line">		propAnnounceDOSMeter.Mark(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we have a valid block number, check that it&#x27;s potentially useful</span></span><br><span class="line">	<span class="comment">// 高度检查</span></span><br><span class="line">	<span class="keyword">if</span> notification.number &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> dist := <span class="keyword">int64</span>(notification.number) - <span class="keyword">int64</span>(f.chainHeight()); dist &lt; -maxUncleDist || dist &gt; maxQueueDist &#123;</span><br><span class="line">			log.Debug(<span class="string">&quot;Peer discarded announcement&quot;</span>, <span class="string">&quot;peer&quot;</span>, notification.origin, <span class="string">&quot;number&quot;</span>, notification.number, <span class="string">&quot;hash&quot;</span>, notification.hash, <span class="string">&quot;distance&quot;</span>, dist)</span><br><span class="line">			propAnnounceDropMeter.Mark(<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All is well, schedule the announce if block&#x27;s not yet downloading</span></span><br><span class="line">	<span class="comment">// 检查是否已经在下载，已下载则忽略</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := f.fetching[notification.hash]; ok &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := f.completing[notification.hash]; ok &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新peer已经通知给我们的区块数量</span></span><br><span class="line">	f.announces[notification.origin] = count</span><br><span class="line">	<span class="comment">// 把通知信息加入到announced，供调度</span></span><br><span class="line">	f.announced[notification.hash] = <span class="built_in">append</span>(f.announced[notification.hash], notification)</span><br><span class="line">	<span class="keyword">if</span> f.announceChangeHook != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(f.announced[notification.hash]) == <span class="number">1</span> &#123;</span><br><span class="line">		f.announceChangeHook(notification.hash, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(f.announced) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="comment">// 有通知放入到announced，则重设0s定时器，loop的另外一个分支会处理这些通知</span></span><br><span class="line">		f.rescheduleFetch(fetchTimer)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fetcher获取完整区块"><a href="#fetcher获取完整区块" class="headerlink" title="fetcher获取完整区块"></a>fetcher获取完整区块</h3><p>本节介绍fetcher获取完整区块的过程，这也是fetcher最重要的功能，会涉及到fetcher至少80%的代码。单独拉放一大节吧。</p>
<h2 id="Fetcher的大头"><a href="#Fetcher的大头" class="headerlink" title="Fetcher的大头"></a>Fetcher的大头</h2><p>Fetcher最主要的功能就是获取完整的区块，然后在合适的实际交给InsertChain去验证和插入到本地区块链。我们还是从宏观入手，看Fetcher是如何工作的，一定要先掌握好宏观，因为代码层面上没有这么清晰。</p>
<h3 id="宏观"><a href="#宏观" class="headerlink" title="宏观"></a>宏观</h3><p>首先，看两个节点是如何交互，获取完整区块，使用时序图的方式看一下，见图6，流程很清晰不再文字介绍。</p>
<p><img src="http://img.lessisbetter.site/image-20180822103401508.png-own" alt="图6：节点获取完整区块的时序图"></p>
<p>再看下获取区块过程中，fetcher内部的状态转移，它使用状态来记录，要获取的区块在什么阶段，见图7。我稍微解释一下：</p>
<ol>
<li>收到<code>NewBlockHashesMsg</code>后，相关信息会记录到<code>announced</code>，进入<code>announced</code>状态，代表了本节点接收了消息。</li>
<li><code>announced</code>由fetcher协程处理，经过校验后，会向给他发送消息的Peer发送请求，请求该区块的区块头，然后进入<code>fetching</code>状态。</li>
<li>获取区块头后，如果区块头表示没有交易和uncle，则转移到<code>completing</code>状态，并且使用区块头合成完整的区块，加入到<code>queued</code>优先级队列。</li>
<li>获取区块头后，如果区块头表示该区块有交易和uncle，则转移到<code>fetched</code>状态，然后发送请求，请求交易和uncle，然后转移到<code>completing</code>状态。</li>
<li>收到交易和uncle后，使用头、交易、uncle这3个信息，生成完整的区块，加入到队列<code>queued</code>。</li>
</ol>
<p><img src="http://img.lessisbetter.site/image-20180822103701006.png-own" alt="图7：获取区块状态转移图"></p>
<h3 id="微观"><a href="#微观" class="headerlink" title="微观"></a>微观</h3><p>接下来就是从代码角度看如何获取完整区块的流程了，有点多，看不懂的时候，再回顾下上面宏观的介绍图。</p>
<p>首先看Fetcher的定义，它存放了通信数据和状态管理，捡加注释的看，上文提到的状态，里面都有。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetcher is responsible for accumulating block announcements from various peers</span></span><br><span class="line"><span class="comment">// and scheduling them for retrieval.</span></span><br><span class="line"><span class="comment">// 积累块通知，然后调度获取这些块</span></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Various event channels</span></span><br><span class="line">    <span class="comment">// 收到区块hash值的通道</span></span><br><span class="line">	notify <span class="keyword">chan</span> *announce</span><br><span class="line">    <span class="comment">// 收到完整区块的通道</span></span><br><span class="line">	inject <span class="keyword">chan</span> *inject</span><br><span class="line"></span><br><span class="line">	blockFilter <span class="keyword">chan</span> <span class="keyword">chan</span> []*types.Block</span><br><span class="line">	<span class="comment">// 过滤header的通道的通道</span></span><br><span class="line">	headerFilter <span class="keyword">chan</span> <span class="keyword">chan</span> *headerFilterTask</span><br><span class="line">	<span class="comment">// 过滤body的通道的通道</span></span><br><span class="line">	bodyFilter <span class="keyword">chan</span> <span class="keyword">chan</span> *bodyFilterTask</span><br><span class="line"></span><br><span class="line">	done <span class="keyword">chan</span> common.Hash</span><br><span class="line">	quit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Announce states</span></span><br><span class="line">	<span class="comment">// Peer已经给了本节点多少区块头通知</span></span><br><span class="line">	announces <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> <span class="comment">// Per peer announce counts to prevent memory exhaustion</span></span><br><span class="line">	<span class="comment">// 已经announced的区块列表</span></span><br><span class="line">	announced <span class="keyword">map</span>[common.Hash][]*announce <span class="comment">// Announced blocks, scheduled for fetching</span></span><br><span class="line">	<span class="comment">// 正在fetching区块头的请求</span></span><br><span class="line">	fetching <span class="keyword">map</span>[common.Hash]*announce <span class="comment">// Announced blocks, currently fetching</span></span><br><span class="line">	<span class="comment">// 已经fetch到区块头，还差body的请求，用来获取body</span></span><br><span class="line">	fetched <span class="keyword">map</span>[common.Hash][]*announce <span class="comment">// Blocks with headers fetched, scheduled for body retrieval</span></span><br><span class="line">	<span class="comment">// 已经得到区块头的</span></span><br><span class="line">	completing <span class="keyword">map</span>[common.Hash]*announce <span class="comment">// Blocks with headers, currently body-completing</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block cache</span></span><br><span class="line">	<span class="comment">// queue，优先级队列，高度做优先级</span></span><br><span class="line">	<span class="comment">// queues，queued队列中某个peer发来的区块数量</span></span><br><span class="line">	<span class="comment">// queued，等待插入到区块链的区块，实际插入时从queue取，queued就是用来快速判断区块是否在队列的</span></span><br><span class="line">	queue  *prque.Prque            <span class="comment">// Queue containing the import operations (block number sorted)</span></span><br><span class="line">	queues <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>          <span class="comment">// Per peer block counts to prevent memory exhaustion</span></span><br><span class="line">	queued <span class="keyword">map</span>[common.Hash]*inject <span class="comment">// Set of already queued blocks (to dedupe imports)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Callbacks</span></span><br><span class="line">	getBlock       blockRetrievalFn   <span class="comment">// Retrieves a block from the local chain</span></span><br><span class="line">	verifyHeader   headerVerifierFn   <span class="comment">// Checks if a block&#x27;s headers have a valid proof of work，验证区块头，包含了PoW验证</span></span><br><span class="line">	broadcastBlock blockBroadcasterFn <span class="comment">// Broadcasts a block to connected peers，广播给peer</span></span><br><span class="line">	chainHeight    chainHeightFn      <span class="comment">// Retrieves the current chain&#x27;s height</span></span><br><span class="line">	insertChain    chainInsertFn      <span class="comment">// Injects a batch of blocks into the chain，插入区块到链的函数</span></span><br><span class="line">	dropPeer       peerDropFn         <span class="comment">// Drops a peer for misbehaving</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Testing hooks</span></span><br><span class="line">	announceChangeHook <span class="function"><span class="keyword">func</span><span class="params">(common.Hash, <span class="keyword">bool</span>)</span> // <span class="title">Method</span> <span class="title">to</span> <span class="title">call</span> <span class="title">upon</span> <span class="title">adding</span> <span class="title">or</span> <span class="title">deleting</span> <span class="title">a</span> <span class="title">hash</span> <span class="title">from</span> <span class="title">the</span> <span class="title">announce</span> <span class="title">list</span></span></span><br><span class="line">	queueChangeHook    <span class="function"><span class="keyword">func</span><span class="params">(common.Hash, <span class="keyword">bool</span>)</span> // <span class="title">Method</span> <span class="title">to</span> <span class="title">call</span> <span class="title">upon</span> <span class="title">adding</span> <span class="title">or</span> <span class="title">deleting</span> <span class="title">a</span> <span class="title">block</span> <span class="title">from</span> <span class="title">the</span> <span class="title">import</span> <span class="title">queue</span></span></span><br><span class="line">	fetchingHook       <span class="function"><span class="keyword">func</span><span class="params">([]common.Hash)</span>     // <span class="title">Method</span> <span class="title">to</span> <span class="title">call</span> <span class="title">upon</span> <span class="title">starting</span> <span class="title">a</span> <span class="title">block</span> <span class="params">(eth/61)</span> <span class="title">or</span> <span class="title">header</span> <span class="params">(eth/62)</span> <span class="title">fetch</span></span></span><br><span class="line">	completingHook     <span class="function"><span class="keyword">func</span><span class="params">([]common.Hash)</span>     // <span class="title">Method</span> <span class="title">to</span> <span class="title">call</span> <span class="title">upon</span> <span class="title">starting</span> <span class="title">a</span> <span class="title">block</span> <span class="title">body</span> <span class="title">fetch</span> <span class="params">(eth/62)</span></span></span><br><span class="line">	importedHook       <span class="function"><span class="keyword">func</span><span class="params">(*types.Block)</span>      // <span class="title">Method</span> <span class="title">to</span> <span class="title">call</span> <span class="title">upon</span> <span class="title">successful</span> <span class="title">block</span> <span class="title">import</span> <span class="params">(both eth/61 and eth/62)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>NewBlockHashesMsg</code>消息的处理<a href="#NewBlockHashesMsg%E7%9A%84%E5%A4%84%E7%90%86">前面的小节已经讲过了</a>，不记得可向前翻看。这里从<code>announced</code>的状态处理说起。<code>loop()</code>中，<code>fetchTimer</code>超时后，代表了收到了消息通知，需要处理，会从<code>announced</code>中选择出需要处理的通知，然后创建请求，请求区块头，由于可能有很多节点都通知了它某个区块的Hash，所以<strong>随机</strong>的从这些发送消息的Peer中选择一个Peer，发送请求的时候，为每个Peer都创建了单独的协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> &lt;-fetchTimer.C:</span><br><span class="line">	<span class="comment">// At least one block&#x27;s timer ran out, check for needing retrieval</span></span><br><span class="line">	<span class="comment">// 有区块通知，去处理</span></span><br><span class="line">	request := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]common.Hash)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> hash, announces := <span class="keyword">range</span> f.announced &#123;</span><br><span class="line">		<span class="keyword">if</span> time.Since(announces[<span class="number">0</span>].time) &gt; arriveTimeout-gatherSlack &#123;</span><br><span class="line">			<span class="comment">// Pick a random peer to retrieve from, reset all others</span></span><br><span class="line">			<span class="comment">// 可能有很多peer都发送了这个区块的hash值，随机选择一个peer</span></span><br><span class="line">			announce := announces[rand.Intn(<span class="built_in">len</span>(announces))]</span><br><span class="line">			f.forgetHash(hash)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// If the block still didn&#x27;t arrive, queue for fetching</span></span><br><span class="line">			<span class="comment">// 本地还没有这个区块，创建获取区块的请求</span></span><br><span class="line">			<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">				request[announce.origin] = <span class="built_in">append</span>(request[announce.origin], hash)</span><br><span class="line">				f.fetching[hash] = announce</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Send out all block header requests</span></span><br><span class="line">	<span class="comment">// 把所有的request发送出去</span></span><br><span class="line">	<span class="comment">// 为每一个peer都创建一个协程，然后请求所有需要从该peer获取的请求</span></span><br><span class="line">	<span class="keyword">for</span> peer, hashes := <span class="keyword">range</span> request &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Fetching scheduled headers&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;list&quot;</span>, hashes)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a closure of the fetch and schedule in on a new thread</span></span><br><span class="line">		fetchHeader, hashes := f.fetching[hashes[<span class="number">0</span>]].fetchHeader, hashes</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> f.fetchingHook != <span class="literal">nil</span> &#123;</span><br><span class="line">				f.fetchingHook(hashes)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, hash := <span class="keyword">range</span> hashes &#123;</span><br><span class="line">				headerFetchMeter.Mark(<span class="number">1</span>)</span><br><span class="line">				fetchHeader(hash) <span class="comment">// Suboptimal, but protocol doesn&#x27;t allow batch header retrievals</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the next fetch if blocks are still pending</span></span><br><span class="line">	f.rescheduleFetch(fetchTimer)</span><br></pre></td></tr></table></figure>

<p>从<code>Notify</code>的调用中，可以看出，<code>fetcherHeader()</code>的实际函数是<code>RequestOneHeader()</code>，该函数使用的消息是<code>GetBlockHeadersMsg</code>，可以用来请求多个区块头，不过fetcher只请求一个。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pm.fetcher.Notify(p.id, block.Hash, block.Number, time.Now(), p.RequestOneHeader, p.RequestBodies)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequestOneHeader is a wrapper around the header query functions to fetch a</span></span><br><span class="line"><span class="comment">// single header. It is used solely by the fetcher.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span> <span class="title">RequestOneHeader</span><span class="params">(hash common.Hash)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	p.Log().Debug(<span class="string">&quot;Fetching single header&quot;</span>, <span class="string">&quot;hash&quot;</span>, hash)</span><br><span class="line">	<span class="keyword">return</span> p2p.Send(p.rw, GetBlockHeadersMsg, &amp;getBlockHeadersData&#123;Origin: hashOrNumber&#123;Hash: hash&#125;, Amount: <span class="keyword">uint64</span>(<span class="number">1</span>), Skip: <span class="keyword">uint64</span>(<span class="number">0</span>), Reverse: <span class="literal">false</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GetBlockHeadersMsg</code>的处理如下：因为它是获取多个区块头的，所以处理起来比较“麻烦”，还好，fetcher只获取一个区块头，其处理在20行~33行，获取下一个区块头的处理逻辑，这里就不看了，最后调用<code>SendBlockHeaders()</code>将区块头发送给请求的节点，消息是<code>BlockHeadersMsg</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMsg()</span></span><br><span class="line"><span class="comment">// Block header query, collect the requested headers and reply</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == GetBlockHeadersMsg:</span><br><span class="line">	<span class="comment">// Decode the complex header query</span></span><br><span class="line">	<span class="keyword">var</span> query getBlockHeadersData</span><br><span class="line">	<span class="keyword">if</span> err := msg.Decode(&amp;query); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errResp(ErrDecode, <span class="string">&quot;%v: %v&quot;</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">	hashMode := query.Origin.Hash != (common.Hash&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Gather headers until the fetch or network limits is reached</span></span><br><span class="line">	<span class="comment">// 收集区块头，直到达到限制</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		bytes   common.StorageSize</span><br><span class="line">		headers []*types.Header</span><br><span class="line">		unknown <span class="keyword">bool</span></span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// 自己已知区块 &amp;&amp; 少于查询的数量 &amp;&amp; 大小小于2MB &amp;&amp; 小于能下载的最大数量</span></span><br><span class="line">	<span class="keyword">for</span> !unknown &amp;&amp; <span class="built_in">len</span>(headers) &lt; <span class="keyword">int</span>(query.Amount) &amp;&amp; bytes &lt; softResponseLimit &amp;&amp; <span class="built_in">len</span>(headers) &lt; downloader.MaxHeaderFetch &#123;</span><br><span class="line">		<span class="comment">// Retrieve the next header satisfying the query</span></span><br><span class="line">		<span class="comment">// 获取区块头</span></span><br><span class="line">		<span class="keyword">var</span> origin *types.Header</span><br><span class="line">		<span class="keyword">if</span> hashMode &#123;</span><br><span class="line">            <span class="comment">// fetcher 使用的模式</span></span><br><span class="line">			origin = pm.blockchain.GetHeaderByHash(query.Origin.Hash)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			origin = pm.blockchain.GetHeaderByNumber(query.Origin.Number)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> origin == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		number := origin.Number.Uint64()</span><br><span class="line">		headers = <span class="built_in">append</span>(headers, origin)</span><br><span class="line">		bytes += estHeaderRlpSize</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Advance to the next header of the query</span></span><br><span class="line">		<span class="comment">// 下一个区块头的获取，不同策略，方式不同</span></span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> query.Origin.Hash != (common.Hash&#123;&#125;) &amp;&amp; query.Reverse:</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> p.SendBlockHeaders(headers)</span><br></pre></td></tr></table></figure>

<p><code>BlockHeadersMsg</code>的处理很有意思，因为<code>GetBlockHeadersMsg</code>并不是fetcher独占的消息，downloader也可以调用，所以，响应消息的处理需要分辨出是fetcher请求的，还是downloader请求的。它的处理逻辑是：fetcher先过滤收到的区块头，如果fetcher不要的，那就是downloader的，在调用<code>fetcher.FilterHeaders</code>的时候，fetcher就将自己要的区块头拿走了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMsg()</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == BlockHeadersMsg:</span><br><span class="line">	<span class="comment">// A batch of headers arrived to one of our previous requests</span></span><br><span class="line">	<span class="keyword">var</span> headers []*types.Header</span><br><span class="line">	<span class="keyword">if</span> err := msg.Decode(&amp;headers); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errResp(ErrDecode, <span class="string">&quot;msg %v: %v&quot;</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If no headers were received, but we&#x27;re expending a DAO fork check, maybe it&#x27;s that</span></span><br><span class="line">	<span class="comment">// 检查是不是当前DAO的硬分叉</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(headers) == <span class="number">0</span> &amp;&amp; p.forkDrop != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Possibly an empty reply to the fork header checks, sanity check TDs</span></span><br><span class="line">		verifyDAO := <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// If we already have a DAO header, we can check the peer&#x27;s TD against it. If</span></span><br><span class="line">		<span class="comment">// the peer&#x27;s ahead of this, it too must have a reply to the DAO check</span></span><br><span class="line">		<span class="keyword">if</span> daoHeader := pm.blockchain.GetHeaderByNumber(pm.chainconfig.DAOForkBlock.Uint64()); daoHeader != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> _, td := p.Head(); td.Cmp(pm.blockchain.GetTd(daoHeader.Hash(), daoHeader.Number.Uint64())) &gt;= <span class="number">0</span> &#123;</span><br><span class="line">				verifyDAO = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If we&#x27;re seemingly on the same chain, disable the drop timer</span></span><br><span class="line">		<span class="keyword">if</span> verifyDAO &#123;</span><br><span class="line">			p.Log().Debug(<span class="string">&quot;Seems to be on the same side of the DAO fork&quot;</span>)</span><br><span class="line">			p.forkDrop.Stop()</span><br><span class="line">			p.forkDrop = <span class="literal">nil</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Filter out any explicitly requested headers, deliver the rest to the downloader</span></span><br><span class="line">	<span class="comment">// 过滤是不是fetcher请求的区块头，去掉fetcher请求的区块头再交给downloader</span></span><br><span class="line">	filter := <span class="built_in">len</span>(headers) == <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> filter &#123;</span><br><span class="line">		<span class="comment">// If it&#x27;s a potential DAO fork check, validate against the rules</span></span><br><span class="line">		<span class="comment">// 检查是否硬分叉</span></span><br><span class="line">		<span class="keyword">if</span> p.forkDrop != <span class="literal">nil</span> &amp;&amp; pm.chainconfig.DAOForkBlock.Cmp(headers[<span class="number">0</span>].Number) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Disable the fork drop timer</span></span><br><span class="line">			p.forkDrop.Stop()</span><br><span class="line">			p.forkDrop = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// Validate the header and either drop the peer or continue</span></span><br><span class="line">			<span class="keyword">if</span> err := misc.VerifyDAOHeaderExtraData(pm.chainconfig, headers[<span class="number">0</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				p.Log().Debug(<span class="string">&quot;Verified to be on the other side of the DAO fork, dropping&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			p.Log().Debug(<span class="string">&quot;Verified to be on the same side of the DAO fork&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Irrelevant of the fork checks, send the header to the fetcher just in case</span></span><br><span class="line">		<span class="comment">// 使用fetcher过滤区块头</span></span><br><span class="line">		headers = pm.fetcher.FilterHeaders(p.id, headers, time.Now())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 剩下的区块头交给downloader</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(headers) &gt; <span class="number">0</span> || !filter &#123;</span><br><span class="line">		err := pm.downloader.DeliverHeaders(p.id, headers)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">&quot;Failed to deliver headers&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>FilterHeaders()</code>是一个很有大智慧的函数，看起来耐人寻味，但实在妙。它要把所有的区块头，都传递给fetcher协程，还要获取fetcher协程处理后的结果。<code>fetcher.headerFilter</code>是存放通道的通道，而<code>filter</code>是存放包含区块头过滤任务的通道。它先把<code>filter</code>传递给了<code>headerFilter</code>，这样<code>fetcher</code>协程就在另外一段等待了，而后将<code>headerFilterTask</code>传入<code>filter</code>，fetcher就能读到数据了，处理后，再将数据写回<code>filter</code>而刚好被<code>FilterHeaders</code>函数处理了，该函数实际运行在<code>handleMsg()</code>的协程中。</p>
<p>每个Peer都会分配一个ProtocolManager然后处理该Peer的消息，但<code>fetcher</code>只有一个事件处理协程，如果不创建一个<code>filter</code>，fetcher哪知道是谁发给它的区块头呢？过滤之后，该如何发回去呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FilterHeaders extracts all the headers that were explicitly requested by the fetcher,</span></span><br><span class="line"><span class="comment">// returning those that should be handled differently.</span></span><br><span class="line"><span class="comment">// 寻找出fetcher请求的区块头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">FilterHeaders</span><span class="params">(peer <span class="keyword">string</span>, headers []*types.Header, time time.Time)</span> []*<span class="title">types</span>.<span class="title">Header</span></span> &#123;</span><br><span class="line">	log.Trace(<span class="string">&quot;Filtering headers&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;headers&quot;</span>, <span class="built_in">len</span>(headers))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send the filter channel to the fetcher</span></span><br><span class="line">	<span class="comment">// 任务通道</span></span><br><span class="line">	filter := <span class="built_in">make</span>(<span class="keyword">chan</span> *headerFilterTask)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="comment">// 任务通道发送到这个通道</span></span><br><span class="line">	<span class="keyword">case</span> f.headerFilter &lt;- filter:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Request the filtering of the header list</span></span><br><span class="line">	<span class="comment">// 创建过滤任务，发送到任务通道</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- &amp;headerFilterTask&#123;peer: peer, headers: headers, time: time&#125;:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Retrieve the headers remaining after filtering</span></span><br><span class="line">	<span class="comment">// 从任务通道，获取过滤的结果并返回</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task := &lt;-filter:</span><br><span class="line">		<span class="keyword">return</span> task.headers</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来要看<code>f.headerFilter</code>的处理，这段代码有90行，它做了以下几件事：</p>
<ol>
<li>从<code>f.headerFilter</code>取出<code>filter</code>，然后取出过滤任务<code>task</code>。</li>
<li>它把区块头分成3类：<code>unknown</code>这不是分是要返回给调用者的，即<code>handleMsg()</code>, <code>incomplete</code>存放还需要获取body的区块头，<code>complete</code>存放只包含区块头的区块。遍历所有的区块头，填到到对应的分类中，具体的判断可看18行的注释，记住宏观中将的状态转移图。</li>
<li>把<code>unknonw</code>中的区块返回给<code>handleMsg()</code>。</li>
<li>把 <code>incomplete</code>的区块头获取状态移动到<code>fetched</code>状态，然后触发定时器，以便去处理<code>complete</code>的区块。</li>
<li>把<code>compelete</code>的区块加入到<code>queued</code>。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetcher.loop()</span></span><br><span class="line"><span class="keyword">case</span> filter := &lt;-f.headerFilter:</span><br><span class="line">	<span class="comment">// Headers arrived from a remote peer. Extract those that were explicitly</span></span><br><span class="line">	<span class="comment">// requested by the fetcher, and return everything else so it&#x27;s delivered</span></span><br><span class="line">	<span class="comment">// to other parts of the system.</span></span><br><span class="line">	<span class="comment">// 收到从远端节点发送的区块头，过滤出fetcher请求的</span></span><br><span class="line">	<span class="comment">// 从任务通道获取过滤任务</span></span><br><span class="line">	<span class="keyword">var</span> task *headerFilterTask</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task = &lt;-filter:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	headerFilterInMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(task.headers)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Split the batch of headers into unknown ones (to return to the caller),</span></span><br><span class="line">	<span class="comment">// known incomplete ones (requiring body retrievals) and completed blocks.</span></span><br><span class="line">	<span class="comment">// unknown的不是fetcher请求的，complete放没有交易和uncle的区块，有头就够了，incomplete放</span></span><br><span class="line">	<span class="comment">// 还需要获取uncle和交易的区块</span></span><br><span class="line">	unknown, incomplete, complete := []*types.Header&#123;&#125;, []*announce&#123;&#125;, []*types.Block&#123;&#125;</span><br><span class="line">	<span class="comment">// 遍历所有收到的header</span></span><br><span class="line">	<span class="keyword">for</span> _, header := <span class="keyword">range</span> task.headers &#123;</span><br><span class="line">		hash := header.Hash()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Filter fetcher-requested headers from other synchronisation algorithms</span></span><br><span class="line">		<span class="comment">// 是正在获取的hash，并且对应请求的peer，并且未fetched，未completing，未queued</span></span><br><span class="line">		<span class="keyword">if</span> announce := f.fetching[hash]; announce != <span class="literal">nil</span> &amp;&amp; announce.origin == task.peer &amp;&amp; f.fetched[hash] == <span class="literal">nil</span> &amp;&amp; f.completing[hash] == <span class="literal">nil</span> &amp;&amp; f.queued[hash] == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// If the delivered header does not match the promised number, drop the announcer</span></span><br><span class="line">			<span class="comment">// 高度校验，竟然不匹配，扰乱秩序，peer肯定是坏蛋。</span></span><br><span class="line">			<span class="keyword">if</span> header.Number.Uint64() != announce.number &#123;</span><br><span class="line">				log.Trace(<span class="string">&quot;Invalid block number fetched&quot;</span>, <span class="string">&quot;peer&quot;</span>, announce.origin, <span class="string">&quot;hash&quot;</span>, header.Hash(), <span class="string">&quot;announced&quot;</span>, announce.number, <span class="string">&quot;provided&quot;</span>, header.Number)</span><br><span class="line">				f.dropPeer(announce.origin)</span><br><span class="line">				f.forgetHash(hash)</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Only keep if not imported by other means</span></span><br><span class="line">			<span class="comment">// 本地链没有当前区块</span></span><br><span class="line">			<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">				announce.header = header</span><br><span class="line">				announce.time = task.time</span><br><span class="line"></span><br><span class="line">				<span class="comment">// If the block is empty (header only), short circuit into the final import queue</span></span><br><span class="line">				<span class="comment">// 如果区块没有交易和uncle，加入到complete</span></span><br><span class="line">				<span class="keyword">if</span> header.TxHash == types.DeriveSha(types.Transactions&#123;&#125;) &amp;&amp; header.UncleHash == types.CalcUncleHash([]*types.Header&#123;&#125;) &#123;</span><br><span class="line">					log.Trace(<span class="string">&quot;Block empty, skipping body retrieval&quot;</span>, <span class="string">&quot;peer&quot;</span>, announce.origin, <span class="string">&quot;number&quot;</span>, header.Number, <span class="string">&quot;hash&quot;</span>, header.Hash())</span><br><span class="line"></span><br><span class="line">					block := types.NewBlockWithHeader(header)</span><br><span class="line">					block.ReceivedAt = task.time</span><br><span class="line"></span><br><span class="line">					complete = <span class="built_in">append</span>(complete, block)</span><br><span class="line">					f.completing[hash] = announce</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Otherwise add to the list of blocks needing completion</span></span><br><span class="line">				<span class="comment">// 否则就是不完整的区块</span></span><br><span class="line">				incomplete = <span class="built_in">append</span>(incomplete, announce)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				log.Trace(<span class="string">&quot;Block already imported, discarding header&quot;</span>, <span class="string">&quot;peer&quot;</span>, announce.origin, <span class="string">&quot;number&quot;</span>, header.Number, <span class="string">&quot;hash&quot;</span>, header.Hash())</span><br><span class="line">				f.forgetHash(hash)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Fetcher doesn&#x27;t know about it, add to the return list</span></span><br><span class="line">			<span class="comment">// 没请求过的header</span></span><br><span class="line">			unknown = <span class="built_in">append</span>(unknown, header)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把未知的区块头，再传递会filter</span></span><br><span class="line">	headerFilterOutMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(unknown)))</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- &amp;headerFilterTask&#123;headers: unknown, time: task.time&#125;:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the retrieved headers for body completion</span></span><br><span class="line">	<span class="comment">// 把未完整的区块加入到fetched，跳过已经在completeing中的，然后触发completeTimer定时器</span></span><br><span class="line">	<span class="keyword">for</span> _, announce := <span class="keyword">range</span> incomplete &#123;</span><br><span class="line">		hash := announce.header.Hash()</span><br><span class="line">		<span class="keyword">if</span> _, ok := f.completing[hash]; ok &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		f.fetched[hash] = <span class="built_in">append</span>(f.fetched[hash], announce)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(f.fetched) == <span class="number">1</span> &#123;</span><br><span class="line">			f.rescheduleComplete(completeTimer)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the header-only blocks for import</span></span><br><span class="line">	<span class="comment">// 把只有头的区块入队列</span></span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> complete &#123;</span><br><span class="line">		<span class="keyword">if</span> announce := f.completing[block.Hash()]; announce != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.enqueue(announce.origin, block)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>跟随状态图的转义，剩下的工作是<code>fetched</code>转移到<code>completing</code>，上面的流程已经触发了<code>completeTimer</code>定时器，超时后就会处理，流程与请求Header类似，不再赘述，此时发送的请求消息是<code>GetBlockBodiesMsg</code>，实际调的函数是<code>RequestBodies</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetcher.loop()</span></span><br><span class="line"><span class="keyword">case</span> &lt;-completeTimer.C:</span><br><span class="line">	<span class="comment">// At least one header&#x27;s timer ran out, retrieve everything</span></span><br><span class="line">	<span class="comment">// 至少有1个header已经获取完了</span></span><br><span class="line">	request := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]common.Hash)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历所有待获取body的announce</span></span><br><span class="line">	<span class="keyword">for</span> hash, announces := <span class="keyword">range</span> f.fetched &#123;</span><br><span class="line">		<span class="comment">// Pick a random peer to retrieve from, reset all others</span></span><br><span class="line">		<span class="comment">// 随机选一个Peer发送请求，因为可能已经有很多Peer通知它这个区块了</span></span><br><span class="line">		announce := announces[rand.Intn(<span class="built_in">len</span>(announces))]</span><br><span class="line">		f.forgetHash(hash)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the block still didn&#x27;t arrive, queue for completion</span></span><br><span class="line">		<span class="comment">// 如果本地没有这个区块，则放入到completing，创建请求</span></span><br><span class="line">		<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">			request[announce.origin] = <span class="built_in">append</span>(request[announce.origin], hash)</span><br><span class="line">			f.completing[hash] = announce</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Send out all block body requests</span></span><br><span class="line">	<span class="comment">// 发送所有的请求，获取body，依然是每个peer一个单独协程</span></span><br><span class="line">	<span class="keyword">for</span> peer, hashes := <span class="keyword">range</span> request &#123;</span><br><span class="line">		log.Trace(<span class="string">&quot;Fetching scheduled bodies&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;list&quot;</span>, hashes)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a closure of the fetch and schedule in on a new thread</span></span><br><span class="line">		<span class="keyword">if</span> f.completingHook != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.completingHook(hashes)</span><br><span class="line">		&#125;</span><br><span class="line">		bodyFetchMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(hashes)))</span><br><span class="line">		<span class="keyword">go</span> f.completing[hashes[<span class="number">0</span>]].fetchBodies(hashes)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the next fetch if blocks are still pending</span></span><br><span class="line">	f.rescheduleComplete(completeTimer)</span><br></pre></td></tr></table></figure>

<p><code>handleMsg()</code>处理该消息也是干净利落，直接获取RLP格式的body，然后发送响应消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMsg()</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == GetBlockBodiesMsg:</span><br><span class="line">	<span class="comment">// Decode the retrieval message</span></span><br><span class="line">	msgStream := rlp.NewStream(msg.Payload, <span class="keyword">uint64</span>(msg.Size))</span><br><span class="line">	<span class="keyword">if</span> _, err := msgStream.List(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Gather blocks until the fetch or network limits is reached</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		hash   common.Hash</span><br><span class="line">		bytes  <span class="keyword">int</span></span><br><span class="line">		bodies []rlp.RawValue</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历所有请求</span></span><br><span class="line">	<span class="keyword">for</span> bytes &lt; softResponseLimit &amp;&amp; <span class="built_in">len</span>(bodies) &lt; downloader.MaxBlockFetch &#123;</span><br><span class="line">		<span class="comment">// Retrieve the hash of the next block</span></span><br><span class="line">		<span class="keyword">if</span> err := msgStream.Decode(&amp;hash); err == rlp.EOL &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errResp(ErrDecode, <span class="string">&quot;msg %v: %v&quot;</span>, msg, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Retrieve the requested block body, stopping if enough was found</span></span><br><span class="line">		<span class="comment">// 获取body，RLP格式</span></span><br><span class="line">		<span class="keyword">if</span> data := pm.blockchain.GetBodyRLP(hash); <span class="built_in">len</span>(data) != <span class="number">0</span> &#123;</span><br><span class="line">			bodies = <span class="built_in">append</span>(bodies, data)</span><br><span class="line">			bytes += <span class="built_in">len</span>(data)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p.SendBlockBodiesRLP(bodies)</span><br></pre></td></tr></table></figure>

<p>响应消息<code>BlockBodiesMsg</code>的处理与处理获取header的处理原理相同，先交给fetcher过滤，然后剩下的才是downloader的。需要注意一点，响应消息里只包含交易列表和叔块列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// handleMsg()</span></span><br><span class="line"><span class="keyword">case</span> msg.Code == BlockBodiesMsg:</span><br><span class="line">	<span class="comment">// A batch of block bodies arrived to one of our previous requests</span></span><br><span class="line">	<span class="keyword">var</span> request blockBodiesData</span><br><span class="line">	<span class="keyword">if</span> err := msg.Decode(&amp;request); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errResp(ErrDecode, <span class="string">&quot;msg %v: %v&quot;</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Deliver them all to the downloader for queuing</span></span><br><span class="line">	<span class="comment">// 传递给downloader去处理</span></span><br><span class="line">	transactions := <span class="built_in">make</span>([][]*types.Transaction, <span class="built_in">len</span>(request))</span><br><span class="line">	uncles := <span class="built_in">make</span>([][]*types.Header, <span class="built_in">len</span>(request))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, body := <span class="keyword">range</span> request &#123;</span><br><span class="line">		transactions[i] = body.Transactions</span><br><span class="line">		uncles[i] = body.Uncles</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Filter out any explicitly requested bodies, deliver the rest to the downloader</span></span><br><span class="line">	<span class="comment">// 先让fetcher过滤去fetcher请求的body，剩下的给downloader</span></span><br><span class="line">	filter := <span class="built_in">len</span>(transactions) &gt; <span class="number">0</span> || <span class="built_in">len</span>(uncles) &gt; <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> filter &#123;</span><br><span class="line">		transactions, uncles = pm.fetcher.FilterBodies(p.id, transactions, uncles, time.Now())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 剩下的body交给downloader</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(transactions) &gt; <span class="number">0</span> || <span class="built_in">len</span>(uncles) &gt; <span class="number">0</span> || !filter &#123;</span><br><span class="line">		err := pm.downloader.DeliverBodies(p.id, transactions, uncles)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Debug(<span class="string">&quot;Failed to deliver bodies&quot;</span>, <span class="string">&quot;err&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>过滤函数的原理也与Header相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FilterBodies extracts all the block bodies that were explicitly requested by</span></span><br><span class="line"><span class="comment">// the fetcher, returning those that should be handled differently.</span></span><br><span class="line"><span class="comment">// 过去出fetcher请求的body，返回它没有处理的，过程类型header的处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Fetcher)</span> <span class="title">FilterBodies</span><span class="params">(peer <span class="keyword">string</span>, transactions [][]*types.Transaction, uncles [][]*types.Header, time time.Time)</span> <span class="params">([][]*types.Transaction, [][]*types.Header)</span></span> &#123;</span><br><span class="line">	log.Trace(<span class="string">&quot;Filtering bodies&quot;</span>, <span class="string">&quot;peer&quot;</span>, peer, <span class="string">&quot;txs&quot;</span>, <span class="built_in">len</span>(transactions), <span class="string">&quot;uncles&quot;</span>, <span class="built_in">len</span>(uncles))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send the filter channel to the fetcher</span></span><br><span class="line">	filter := <span class="built_in">make</span>(<span class="keyword">chan</span> *bodyFilterTask)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> f.bodyFilter &lt;- filter:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Request the filtering of the body list</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- &amp;bodyFilterTask&#123;peer: peer, transactions: transactions, uncles: uncles, time: time&#125;:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Retrieve the bodies remaining after filtering</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task := &lt;-filter:</span><br><span class="line">		<span class="keyword">return</span> task.transactions, task.uncles</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际过滤body的处理瞧一下，这和Header的处理是不同的。直接看不点：</p>
<ol>
<li>它要的区块，单独取出来存到<code>blocks</code>中，它不要的继续留在<code>task</code>中。</li>
<li>判断是不是fetcher请求的方法：如果交易列表和叔块列表计算出的hash值与区块头中的一样，并且消息来自请求的Peer，则就是fetcher请求的。</li>
<li>将<code>blocks</code>中的区块加入到<code>queued</code>，终结。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> filter := &lt;-f.bodyFilter:</span><br><span class="line">	<span class="comment">// Block bodies arrived, extract any explicitly requested blocks, return the rest</span></span><br><span class="line">	<span class="keyword">var</span> task *bodyFilterTask</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> task = &lt;-filter:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	bodyFilterInMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(task.transactions)))</span><br><span class="line"></span><br><span class="line">	blocks := []*types.Block&#123;&#125;</span><br><span class="line">	<span class="comment">// 获取的每个body的txs列表和uncle列表</span></span><br><span class="line">	<span class="comment">// 遍历每个区块的txs列表和uncle列表，计算hash后判断是否是当前fetcher请求的body</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(task.transactions) &amp;&amp; i &lt; <span class="built_in">len</span>(task.uncles); i++ &#123;</span><br><span class="line">		<span class="comment">// Match up a body to any possible completion request</span></span><br><span class="line">		matched := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历所有保存的请求，因为tx和uncle，不知道它是属于哪个区块的，只能去遍历所有的请求，通常量不大，所以遍历没有性能影响</span></span><br><span class="line">		<span class="keyword">for</span> hash, announce := <span class="keyword">range</span> f.completing &#123;</span><br><span class="line">			<span class="keyword">if</span> f.queued[hash] == <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="comment">// 把传入的每个块的hash和unclehash和它请求出去的记录进行对比，匹配则说明是fetcher请求的区块body</span></span><br><span class="line">				txnHash := types.DeriveSha(types.Transactions(task.transactions[i]))</span><br><span class="line">				uncleHash := types.CalcUncleHash(task.uncles[i])</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> txnHash == announce.header.TxHash &amp;&amp; uncleHash == announce.header.UncleHash &amp;&amp; announce.origin == task.peer &#123;</span><br><span class="line">					<span class="comment">// Mark the body matched, reassemble if still unknown</span></span><br><span class="line">					matched = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">					<span class="comment">// 如果当前链还没有这个区块，则收集这个区块，合并成新区块</span></span><br><span class="line">					<span class="keyword">if</span> f.getBlock(hash) == <span class="literal">nil</span> &#123;</span><br><span class="line">						block := types.NewBlockWithHeader(announce.header).WithBody(task.transactions[i], task.uncles[i])</span><br><span class="line">						block.ReceivedAt = task.time</span><br><span class="line"></span><br><span class="line">						blocks = <span class="built_in">append</span>(blocks, block)</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						f.forgetHash(hash)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从task中移除fetcher请求的数据</span></span><br><span class="line">		<span class="keyword">if</span> matched &#123;</span><br><span class="line">			task.transactions = <span class="built_in">append</span>(task.transactions[:i], task.transactions[i+<span class="number">1</span>:]...)</span><br><span class="line">			task.uncles = <span class="built_in">append</span>(task.uncles[:i], task.uncles[i+<span class="number">1</span>:]...)</span><br><span class="line">			i--</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将剩余的数据返回</span></span><br><span class="line">	bodyFilterOutMeter.Mark(<span class="keyword">int64</span>(<span class="built_in">len</span>(task.transactions)))</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> filter &lt;- task:</span><br><span class="line">	<span class="keyword">case</span> &lt;-f.quit:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Schedule the retrieved blocks for ordered import</span></span><br><span class="line">	<span class="comment">// 把收集的区块加入到队列</span></span><br><span class="line">	<span class="keyword">for</span> _, block := <span class="keyword">range</span> blocks &#123;</span><br><span class="line">		<span class="keyword">if</span> announce := f.completing[block.Hash()]; announce != <span class="literal">nil</span> &#123;</span><br><span class="line">			f.enqueue(announce.origin, block)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>至此，fetcher获取完整区块的流程讲完了，fetcher模块中80%的代码也都贴出来了，还有2个值得看看的函数：</p>
<ol>
<li><code>forgetHash(hash common.Hash) </code>：用于清空指定hash值的记/状态录信息。</li>
<li><code>forgetBlock(hash common.Hash)</code>：用于从队列中移除一个区块。</li>
</ol>
<p>最后了，再回到开始看看fetcher模块和新区块的传播流程，有没有豁然开朗。</p>
<blockquote>
<ol>
<li>如果这篇文章对你有帮助，不妨关注下我的Github，有文章会收到通知。</li>
<li>本文作者：<a href="http://lessisbetter.site/about/">大彬</a></li>
<li>如果喜欢本文，随意转载，但请保留此原文链接：<a href="http://lessisbetter.site/2018/08/30/ethereum-fetcher-module-and-block-propagate/">http://lessisbetter.site/2018/08/30/ethereum-fetcher-module-and-block-propagate/</a></li>
</ol>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag"># 区块链</a>
              <a href="/tags/%E4%BB%A5%E5%A4%AA%E5%9D%8A/" rel="tag"># 以太坊</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/06/22/ethereum-code-consensus-3/" rel="prev" title="以太坊源码分析：共识（3）PoW">
                  <i class="fa fa-chevron-left"></i> 以太坊源码分析：共识（3）PoW
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/09/04/explore-golang-timer/" rel="next" title="探索Golang定时器的陷阱">
                  探索Golang定时器的陷阱 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">浙ICP </a><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=18051706" rel="noopener" target="_blank">备18051706 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大彬</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  

<script src="//cdn.jsdelivr.net/npm/algoliasearch@4.8.2/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4.8.7/dist/instantsearch.production.min.js"></script><script src="/js/algolia-search.js"></script>






  






<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.css">

<script>
NexT.utils.loadComments('#gitalk-container', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1.7.0/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '5bfe6f6d1ad3c04f357d',
      clientSecret: 'c60d7cdad469c9afd60947dd84c0f4100874c655',
      repo        : 'shitaibin.github.io',
      owner       : 'Shitaibin',
      admin       : ['Shitaibin'],
      id          : 'fc09b3a6fbbc653bbf465e7483576345',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
